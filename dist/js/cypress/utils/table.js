"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTable = exports.parseValue = void 0;
const get_1 = __importDefault(require("lodash/get"));
const moment_1 = __importDefault(require("moment"));
const random_seed_1 = __importDefault(require("random-seed"));
const cache_1 = require("./cache");
/**
 * Checks whether passed string is integer number.
 */
function isInteger(str) {
    return /^\d+$/.test(str);
}
/**
 * Evaluates expression from passed string.
 * See https://www.jayway.com/2012/04/03/cucumber-data-driven-testing-tips/ for more information.
 * The rules are:
 *  - ${} – everything inside will be parsed, strings are comma separated
 *  - numerical value – create random alphanumeric string
 *  - ! – use the string as it is
 *  - N – random numbers
 *  - d - date in
 * Math.random().toString(36) is used to generate random string.
 */
function evalExpression(str) {
    if (isInteger(str)) {
        /**
         * Seed is generated by timestamp + random string.
         * Additional random string is required, because using only seed for generating string in loop
         * will cause random string duplication.
         */
        const seed = new Date().getTime().toString() + Math.random().toString(36);
        const rand = random_seed_1.default.create(seed);
        const alphabet = "abcdefghijklmnopqrstuvwxyz";
        const randomLetter = alphabet[Math.floor(rand.random() * alphabet.length)];
        // !!!IMPORTANT Random letter is required in generated string because of
        // issue https://exabyte.atlassian.net/browse/SOF-1719
        // Generated string is used for username generation. In case of random string contains only numbers
        // slug for default issue will be inappropriate (e.g., "user-1232" has "user" slug).
        return (randomLetter +
            rand
                .random()
                .toString(36)
                .substring(2, 2 + parseInt(str, 10) - 1));
    }
    if (str.indexOf("!") === 0) {
        // ! – use the string as it is
        return str.substring(1);
    }
    if (str.indexOf("N") === 0) {
        // random numbers
        let result = "";
        const max = 9;
        const min = 0;
        const count = parseInt(str.substring(1), 10);
        let i = 0;
        for (; i < count; i++) {
            result += Math.floor(Math.random() * (max - min + 1)) + min;
        }
        return result;
    }
    return "";
}
/**
 * Parses passed string and returns evaluated value.
 */
function parseValue(str) {
    // eslint-disable-next-line no-shadow, no-use-before-define, @typescript-eslint/no-use-before-define
    const config = REGEXES.find((config) => str.match(config.regex));
    return (config ? config.func(str, config.regex, context) : str);
}
exports.parseValue = parseValue;
/**
 * @summary Parses values from table rows. Each column's value for each row are parsed by parseValue.
 * @param table Table passed from Cucumber step definition.
 * @param context  Context for extracting cached values.
 */
function parseTable(table) {
    return table.hashes().map((hash) => {
        const entries = Object.entries(hash).map(([key, value]) => [key, parseValue(value)]);
        return Object.fromEntries(entries);
    });
}
exports.parseTable = parseTable;
/**
 * Parses basis string in format "Si 0 0 0, Li 0.5 0.5 0.5" and returns it as an object in exabyte internal format.
 */
function parseBasisStr(str) {
    const lines = str.split(/[,;]/).map((x) => x.trim());
    const basis = {
        elements: [],
        coordinates: [],
        units: "crystal",
    };
    for (let i = 0; i < lines.length; i++) {
        const items = lines[i].split(" ");
        basis.elements.push({
            id: i + 1,
            value: items[0],
        });
        basis.coordinates.push({
            id: i + 1,
            value: [items[1], items[2], items[3]].map(parseFloat),
        });
    }
    return basis;
}
function matchRegexp(str, regex) {
    const match = str.match(regex);
    if (!match) {
        throw new Error("DATE_REGEX REGEX ERROR");
    }
    return match[1];
}
const REGEXES = [
    {
        name: "DATE_REGEX",
        regex: /^\$DATE\{(.*)}/,
        func: (str, regex) => new Date(matchRegexp(str, regex)).toISOString(),
    },
    {
        name: "DATE_AGO_REGEX",
        regex: /^\$DATE_AGO\{(.*)}/,
        func: (str, regex) => {
            const matched = str.match(regex);
            if (!matched) {
                return null;
            }
            const [num, type] = matched[1].split("/");
            return (0, moment_1.default)()
                .subtract(num, type)
                .toDate()
                .toISOString();
        },
    },
    {
        name: "BOOLEAN_REGEX",
        regex: /^\$BOOLEAN\{(.*)}/,
        func: (str, regex) => JSON.parse(matchRegexp(str, regex)),
    },
    {
        name: "ARRAY_REGEX",
        regex: /^\$ARRAY\{(.*)}/,
        func: (str, regex) => matchRegexp(str, regex).split(","),
    },
    {
        name: "INT_REGEX",
        regex: /^\$INT\{(.*)}/,
        func: (str, regex) => parseInt(matchRegexp(str, regex), 10),
    },
    {
        name: "JSON_REGEX",
        regex: /^\$JSON\{(.*)}/,
        func: (str, regex) => {
            const matched = str.match(regex);
            return JSON.parse(matched ? matched[1] : "");
        },
    },
    {
        name: "EVAL_REGEX",
        regex: /^\$EVAL\{(.*)}/,
        func: (str, regex) => {
            const match = str.match(regex);
            // eslint-disable-next-line no-new-func
            return Function('"use strict";return (' + (match ? match[1] : null) + ")")();
        },
    },
    {
        name: "FLOAT_REGEX",
        regex: /^\$FLOAT\{(.*)}/,
        func: (str, regex) => parseFloat(matchRegexp(str, regex)),
    },
    {
        name: "BASIS_REGEX",
        regex: /^\$BASIS\{(.*)}/,
        func: (str, regex) => parseBasisStr(matchRegexp(str, regex)),
    },
    {
        name: "EXPR_REGEX",
        regex: /^\$\{(.*)}/,
        func: (str, regex) => {
            return matchRegexp(str, regex)
                .split(",")
                .map(evalExpression)
                .reduceRight((mem, part) => part + mem, "");
        },
    },
    {
        name: "CACHE_REGEX",
        // eslint-disable-next-line no-useless-escape
        regex: /\$CACHE\{([^\{^}]*)}/,
        func: (str, regex) => {
            const value = matchRegexp(str, regex);
            const [contextKey, property] = value.split(":");
            return parseValue(str.replace(`$CACHE{${value}}`, (0, get_1.default)((0, cache_1.getCacheValue)(contextKey), property)));
        },
    },
];
